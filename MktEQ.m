function [Paths,Flows,LagrM,ReducedCosts,basefval]=MktEQ(Samples,Capacities,S2Pop,itermax)

%this function determines the market equilibrium for a population with
%capacitated infrastructure, where individuals' parameters are sampled
%This script corresponds to ALGORITHM 1 in: Chow, J.Y.J., Djavadian, S., 2015. Activity-based market
%equilibrium for capacitated multimodal transport systems, Transportation Research Part C, Special Issue
%from ISTTT 21, in press, doi:10.1016/j.trc.2015.04.028.

%INPUT
%Samples -- this is the set of S samples of input parameters, a cell of Sx(Linkx, Linkt, Activities,
%TransNodes, Coeff, for each individual/class
%Capacities - this is the maximum flow capacity (persons/unit time) through 
%a link (as a travel time on a link) or a transport node (through parking node or
%duration at transit station),[u w Capacity]
%S2Pop - this is the scale factor from the sample to the population, by 
%class, Sx1 

%OUTPUT 
%Paths - output daily itineraries generated by the algorithm, broken down 
%by sampled class: X,T,fval(maximize) 
%Flows - population that uses the Paths 
%Lambdas - the optimal Lagrange multiplier(s) for the service capacities 
%Utilities -- reduced cost utilities of each path for the class 

%Initiate 
numS=size(Samples,1); %number of samples 
Paths=cell(numS,7); 
Flows=cell(numS,1); %Flows will grow in cells by column within cell 1 
ReducedCosts=cell(numS,1); 
basefval=cell(numS,1); 
stop=0; 
iter=1; 

for i=1:numS 
    [Paths{i,1},Paths{i,2},Paths{i,3},Paths{i,4},Paths{i,5},Paths{i,6}{1,1},Paths{i,7},~,~]=mHAPPcap(Samples{i,1},Samples{i,2},Samples{i,3},Samples{i,4},Samples{i,5},[0 0 0],[]);
    Flows{i,1}=S2Pop(i,1); 
    basefval{i,1}=Paths{i,7}; 
end 

while stop==0
%loop until pricing
%Determine max flows on network based on population Flows
%for now we hardcode the max capacity to one link or node
    Q=0; %for multiple capacities, we would have a vector of this
    MaxQ=0;
    MaxQTimeBegin=0;
    MaxQTimeEnd=0;
    Arrivals=[];
    AffLinks=[];
    for i=1:numS
        N=size(Samples{i,3},1)*2+2;
        Nplus=(N-2)/2;
        Linkxp=Samples{i,1}; %since dropoffs are at home too
        for n=1:size(Linkxp,1)
            for j=1:4
                if and(Linkxp(n,j)>Nplus,Linkxp(n,j)<=N-1)
                    Linkxp(n,j)=0;
                end
            end
        end
        for j=1:size(Flows{i,iter},2)
            for n=1:size(Samples{i,1},1)
                if and(Linkxp(n,3)==Capacities(1,1),and(Linkxp(n,4)==Capacities(1,2),Paths{i,1}(n,j)==1))
                    if Linkxp(n,3)==Linkxp(n,1)
                        Arrivals=[Arrivals; Paths{i,2}(1+Samples{i,1}(n,3),j) Flows{i,iter}(1,j)];
                        Arrivals=[Arrivals; Paths{i,2}(1+Samples{i,1}(n,3),j)+Linkxp(n,8) -
                        Flows{i,iter}(1,j)]; %this is the change to travel time-based
                        if and(i==1,j==1)
                            AffLinks=[AffLinks; n];
                        end
                    end
                    for t=1:size(Samples{i,2},1)
                        if and(Samples{i,1}(n,1)==Samples{i,2}(t,1),and(Samples{i,1}(n,2)==Samples{i,2}(t,2),Samples{i,1}(n,3)==Samples{i,2}(t,3)))
                            Arrivals=[Arrivals; Paths{i,2}(N+t,j) Flows{i,iter}(1,j)];
                            Arrivals=[Arrivals; Paths{i,2}(N+t,j)+Linkxp(n,8) -Flows{i,iter}(1,j)];
                            if and(i==1,j==1)
                                AffLinks=[AffLinks; n];
                            end
                        end
                    end
                end
            end
        end
    end

    %this determines range from oversaturated queue
    [~,ind]=sort(Arrivals(:,1));
    for i=1:size(Arrivals,1)
        if and(Q>=Capacities(1,3),Q+Arrivals(ind(i,1),2)<Capacities(1,3))
            MaxQTimeEnd=Arrivals(ind(i,1),1);
        end
        Q=Q+Arrivals(ind(i,1),2);
    end
    for i=1:size(Arrivals,1)
        if and(Q>=Capacities(1,3),Q-Arrivals(ind(size(Arrivals,1)-i+1,1),2)<Capacities(1,3))
            MaxQTimeBegin=Arrivals(ind(size(Arrivals,1)-i+1,1),1);
        end
        Q=Q-Arrivals(ind(size(Arrivals,1)-i+1,1),2);
    end

    [MaxQTimeBegin MaxQTimeEnd]
    %For max flows over capacity, obtain optimal Lambdas
    if MaxQTimeEnd-MaxQTimeBegin>0
    %if MaxQ>=Capacities(1,3)
        maxedout=0;
        Lambdas=1;
        oldfval=0;
        while maxedout==0
            LagrM=[Lambdas MaxQTimeBegin MaxQTimeEnd];
            newfval=0;
            for i=1:numS
                [~,~,~,~,~,~,fval,~,~]=mHAPPcap(Samples{i,1},Samples{i,2},Samples{i,3},Samples{i,4},Samples{i,5},LagrM,AffLinks);
                for j=1:size(Flows{i,iter},2)
                    newfval=newfval+fval*Flows{i,iter}(1,j);
                end
            end
            if newfval<=oldfval
                maxedout=1;
            else
                Lambdas=Lambdas+1;
                oldfval=newfval;
            end
        end
        %Lambdas
        LagrM=[Lambdas MaxQTimeBegin MaxQTimeEnd];
        %update the path set
        incap=cell(numS,1); %this is to keep track of whether a path is in the capacity
        basefval=cell(numS,1);
        notequal=zeros(numS,1);
        for i=1:numS
            N=size(Samples{i,3},1)*2+2;
            Nplus=(N-2)/2;
            [X,T,P,Qp,Qm,Y,fval,~,~]=mHAPPcap(Samples{i,1},Samples{i,2},Samples{i,3},Samples{i,4},Samples{i,5},LagrM,AffLinks);
            for j=1:size(Paths{i,7},2)
                if T(1:Nplus+1,1)==Paths{i,2}(1:Nplus+1,j)
                    notequal(i,1)=1;
                end
            end
            if notequal(i,1)==0
                Paths{i,1}=[Paths{i,1} X];
                Paths{i,2}=[Paths{i,2} T];
                Paths{i,3}=[Paths{i,3} P];
                Paths{i,4}=[Paths{i,4} Qp];
                Paths{i,5}=[Paths{i,5} Qm];
                Paths{i,6}{1,size(Paths{i,5},2)}=Y;
                Paths{i,7}=[Paths{i,7} fval];
                ReducedCosts{i,1}=[ReducedCosts{i,1} fval];
                incap{i,1}=[incap{i,1} 0];
            end
        end

        %update reduced costs
        for i=1:numS
            N=size(Samples{i,3},1)*2+2;
            numV=max(Samples{i,4}(:,1));
            numX=size(Samples{i,1},1);
            numtnodes=size(Samples{i,2},1);
            Nplus=(N-2)/2;
            numY=size(AffLinks,1);
            numVar=numX+N+numtnodes+Nplus*2+numtnodes*2+numY*3;

            %Minimization objective
            Obj=zeros(7+numV,numVar);
            %Obj z1 - min cost
            Obj(1,1:numX)=Samples{i,5}(1,1)*Samples{i,1}(:,7)';
            %Obj z2 - min travel time
            Obj(2,1:numX)=Samples{i,5}(2,1)*Samples{i,1}(:,8)';
            %Obj z3 - min parking cost
            for l=1:numtnodes
                if Samples{i,2}(l,4)==1
                    Obj(3,numX+N+numtnodes+Nplus*2+l)=Samples{i,5}(3,1)*Samples{i,4}(Samples{i,2}(l,3)-N+1,2);
                    Obj(3,numX+N+numtnodes+Nplus*2+numtnodes+l)=-Samples{i,5}(3,1)*Samples{i,4}(Samples{i,2}(l,3)-N+1,2);
                end
            end
            for l=1:numX
                if Samples{i,1}(l,6)==1
                    Obj(3,l)=Samples{i,5}(3,1)*Samples{i,4}(Samples{i,1}(l,4)-N+1,3);
                end
            end
            %Obj z4 - mode-specific constant
            for l=1:numX
                if and(Samples{i,1}(l,1)==Samples{i,1}(l,3),Samples{i,1}(l,6)>0)
                    Obj(3+Samples{i,1}(l,6),l)=-Samples{i,5}(3+Samples{i,1}(l,6),1);
                end
            end
            %Obj z5 - activity return home delay
            Obj(4+numV,numX+1+1:numX+1+Nplus)=-Samples{i,5}(4+numV,1);
            Obj(4+numV,numX+1+Nplus+1:numX+1+2*Nplus)=Samples{i,5}(4+numV,1);
            %Obj z6 - min length of day
            Obj(5+numV,numX+N)=Samples{i,5}(5+numV,1);
            Obj(5+numV,numX+1)=-Samples{i,5}(5+numV,1);

            %Obj z7 - early penalty
            for u=1:Nplus
                Obj(6+numV,numX+N+numtnodes+u)=Samples{i,5}(5+numV+u,1);
                %Obj z8 - late penalty
                Obj(7+numV,numX+N+numtnodes+Nplus+u)=Samples{i,5}(5+numV+Nplus+u,1);
            end

            %Lagrange multiplier
            % Obj(8+numV,numX+N+numtnodes+Nplus*2+numtnodes*2+numY*2+1:numVar)=LagrM(1,1);
            for j=1:size(Paths{i,7},2)
                incap{i,1}(1,j)=0;
                basefval{i,1}(1,j)=sum(Obj(1:7+numV,1:numX+N+numtnodes+Nplus*2+numtnodes*2),1)*[Paths{i,1}(:,j);
                Paths{i,2}(:,j); Paths{i,3}(:,j); Paths{i,4}(:,j); Paths{i,5}(:,j)];
                ReducedCosts{i,1}(1,j)=sum(Obj(1:7+numV,1:numX+N+numtnodes+Nplus*2+numtnodes*2),1)*[Paths{i,1}(:,j);
                Paths{i,2}(:,j); Paths{i,3}(:,j); Paths{i,4}(:,j); Paths{i,5}(:,j)];
                for y=1:numY
                    if Paths{i,1}(AffLinks(y,1),j)==1
                        if Samples{i,1}(AffLinks(y,1),1)==Samples{i,1}(AffLinks(y,1),3)
                        %need to make a correction:
                            if and(Paths{i,2}(1+Samples{i,1}(AffLinks(y,1),1),j)>LagrM(1,2)-Samples{i,1}(AffLinks(y,1),8),Paths{i,2}(1+Samples{i,1}(AffLinks(y,1),1),j)<LagrM(1,3))
                                ReducedCosts{i,1}(1,j)=ReducedCosts{i,1}(1,j)+LagrM(1,1);
                                incap{i,1}(1,j)=1;
                            end
                        else
                            for t=1:numtnodes
                                if and(Samples{i,1}(AffLinks(y,1),1)==Samples{i,2}(t,1),and(Samples{i,1}(AffLinks(y,1),2)==Samples{i,2}(t,2),Samples{i,1}(AffLinks(y,1),3)==Samples{i,2}(t,3)))
                                    if and(Paths{i,2}(N+t,j)>LagrM(1,2)-Samples{i,1}(AffLinks(y,1),8),Paths{i,2}(N+t,j)<LagrM(1,3))
                                        ReducedCosts{i,1}(1,j)=ReducedCosts{i,1}(1,j)+LagrM(1,1);
                                        incap{i,1}(1,j)=1;
                                    end
                                end
                            end
                        end
                    end
                end

            end
            incap{i,1}
        end
        %update path flows
        capcount=0; %this will track total percent that is within the capacity range
        noncapcount=zeros(numS,1);
        AuxFlows=cell(numS,1);
        for i=1:numS
            denom=zeros(size(Paths{i,7},2),size(Paths{i,7},2));
            for j=1:size(Paths{i,7},2)
                for k=1:size(Paths{i,7},2)
                    denom(j,k)=exp(-basefval{i,1}(1,k)+basefval{i,1}(1,j));
                end
                AuxFlows{i,1}(1,j)=S2Pop(i,1)*1/(sum(denom(j,:)));
                if incap{i,1}(1,j)==1
                    capcount=capcount+AuxFlows{i,1}(1,j);
                else
                    noncapcount(i,1)=noncapcount(i,1)+AuxFlows{i,1}(1,j);
                end
            end
        end

        %for capacities
        noncapchange=zeros(numS,1); %this keeps track of how much adjustment is needed in noncap paths
        for i=1:numS
            for j=1:size(Paths{i,7},2)
                if incap{i,1}(1,j)==1
                    noncapchange(i,1)=noncapchange(i,1)+(AuxFlows{i,1}(1,j)-(AuxFlows{i,1}(1,j)/capcount)*Capacities(1,3));
                    AuxFlows{i,1}(1,j)=(AuxFlows{i,1}(1,j)/capcount)*Capacities(1,3);
                end
            end
        end
        %for noncaps
        for i=1:numS
            for j=1:size(Paths{i,7},2)
                if incap{i,1}(1,j)~=1
                    AuxFlows{i,1}(1,j)=max(0,AuxFlows{i,1}(1,j)*(noncapcount(i,1)+noncapchange(i,1))/noncapcount(i,1));
                end
            end
        end

        %MSA move to Flows
        for i=1:numS
            for j=1:size(AuxFlows{i,1},2)
                if j<=size(Flows{i,iter},2)
                    Flows{i,iter+1}(1,j)=(1/(1+iter))*AuxFlows{i,1}(1,j)+(iter/(1+iter))*Flows{i,iter}(1,j);
                else
                    Flows{i,iter+1}(1,j)=(1/(1+iter))*AuxFlows{i,1}(1,j);
                end
            end
        end

        %tolerance check
        if iter<itermax
            iter=iter+1
        else
            stop=1
        end
    else
        stop=1;
        LagrM=[0 0 0];
    end
end